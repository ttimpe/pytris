<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title></title>
	<style>
	@font-face {
    font-family: 'munroregular';
    src: url('fonts/munro-webfont.eot');
    src: url('fonts/munro-webfont.eot?#iefix') format('embedded-opentype'),
         url('fonts/munro-webfont.woff') format('woff'),
         url('fonts/munro-webfont.ttf') format('truetype'),
         url('fonts/munro-webfont.svg#munroregular') format('svg');
    font-weight: normal;
    font-style: normal;

}
		body {
			background-color: gray;
			width: 100%;
			height: 100%;

		}
		#gameCanvas {
			border: 3px solid black;
			position: absolute;
			width: 400px;
			height: 600px;
			left:50%;
			top:50%;
			margin-left: -200px;
			margin-top: -300px;
		}
	</style>
</head>
<body>
	<canvas id="gameCanvas" width="400" height="600"></canvas>
<script>
	var c = document.getElementById('gameCanvas');

	sizeX = 50;
	sizeY = sizeX * 0.8;
	ctx = c.getContext('2d');

	var width = 8;
	var height = 15;
	var borderWidth = 5;

	var color = 0;
	
	var gameInProgress = false;
	var gameOver = false;
	
	var goFrame = 0;
	var blinky = false;
function backingScale(context) {
    if ('devicePixelRatio' in window) {
        if (window.devicePixelRatio > 1) {
            return window.devicePixelRatio;
        }
    }
    return 1;
}

var scaleFactor = backingScale(ctx);
 
if (scaleFactor > 1) {
    c.width = c.width * scaleFactor;
    c.height = c.height * scaleFactor;
    sizeX=sizeX*scaleFactor;
    sizeY=sizeX*0.8;
    // update the context for the new canvas scale
    ctx = c.getContext("2d");
}

	var blocks;


	var currentBlock;


	

	function Block() {
		this.x = 0;
		this.y = 0;
		this.color = 0;
		this.value = 0;
		this.isFacingDown = false;
	}



	function random(min, max) {
		return parseInt(Math.random() * (max - min) + min);
	}
	// draw methods
	function drawLine(x1, y1, x2, y2) {
		ctx.beginPath();
      	ctx.moveTo(x1, y1);
      	ctx.lineTo(x2, y2);
      	ctx.stroke();
	}
	function drawRect(x, y, width, height) {
		ctx.beginPath();
      	ctx.moveTo(x, y);
      	ctx.lineTo(x + width, y);
      	ctx.lineTo(x + width, y + height);
      	ctx.lineTo(x, y + height);
      	ctx.stroke();
	}
	function drawTriangle(x, y, block) {
		ctx.fillStyle = 'hsl(' + (block.color * 36) + ', 100%, 50%)';
		ctx.beginPath();
    	if (block.isFacingDown) {
    		ctx.moveTo(x, y);
    		ctx.lineTo(x + sizeX, y);
   			ctx.lineTo(x + sizeX / 2, y + sizeY);
    	} else {
    		ctx.moveTo(x, y + sizeY);
    		ctx.lineTo(x + sizeX, y + sizeY);
    		ctx.lineTo(x + sizeX / 2, y);
    	}
    	ctx.fill();
    	ctx.font = "bold "+(16*scaleFactor)+"px Arial";
    	if (block.color < 6) {
    		ctx.fillStyle = '#000';
    	} else {
    		ctx.fillStyle = '#fff';
    	}
    	if (block.isFacingDown) {
    		ctx.fillText(block.value, x + sizeX / 2 - ctx.measureText(block.value).width / 2, y + sizeY / 2);
    	} else {
    		ctx.fillText(block.value, x + sizeX / 2 - ctx.measureText(block.value).width / 2, y + parseInt(sizeY * 0.8));
    	}
	}
	function drawBoard() {
		ctx.strokeStyle = '#000';
		for (var x = 0; x < width; x++) {
			drawLine(x * sizeX, 0, x * sizeX, c.height);
		}
		for (var y = 0; y < height; y++) {
			drawLine(0, y * sizeY, c.width, y * sizeY);
		}
	}
	function drawGameOver() {
			var goString = "GAME";

	if (goFrame < (c.width / 2 )) {
		ctx.fillStyle = 'black';
		ctx.fillRect(0,0,(sizeX*width), (sizeY*height));
		ctx.fillStyle = "red";
		ctx.strokeStyle = "white";
    	ctx.font = "bold "+(48*scaleFactor)+"px munroregular";
		var dist = goFrame;
		
		console.log('game at: ' + dist);
		
		ctx.fillText('GAME', dist-(ctx.measureText('GAME').width+20), (height*sizeY) / 2);
		var len = (c.width/1.3) + ctx.measureText('OVER').width+20;
		ctx.fillText('OVER', len - dist, (height*sizeY) / 2);

		
		goFrame=goFrame+5;
		} else {

		goFrame = 0;
		gameOver = false;
		}
	}

	function drawPlayAgainMessage() {
		ctx.fillStyle = "white";
		var message = "Press [ENTER] or tap to play again"
    	ctx.font = "bold "+(20*scaleFactor)+"px munroregular";
		var dist = goFrame;
		if (blinky) {
					ctx.fillStyle = "white";
}
else {
			ctx.fillStyle = "black";

}
		ctx.fillText(message, c.width / 2 - ctx.measureText(message).width / 2, (height*sizeY) * 0.8);


	}
	function gameTick() {
		if (gameInProgress) {
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, c.width, c.height);
		drawBoard();
		for (var x = 0; x < blocks.length; x++) {
			for (var y = 0; y < blocks[x].length; y++) {
				if (blocks[x][y] != null) {
				blocks[x][y].isFacingDown = true;
				drawTriangle(x * sizeX, y * sizeY, blocks[x][y]);
			}
			}
		}
		
		} else if (gameOver) {
			drawGameOver(goFrame);
			drawPlayAgainMessage();

		}
	}
	function invertBlink() {
		blinky = !blinky;
	}
	function spawnRandomBlock() {
		var x = random(0, width);
		currentBlock = new Block();
		currentBlock.color = random(1, 10);
		currentBlock.value = random(1, 10);
		currentBlock.x = x;
		currentBlock.y = 0;
		blocks[x][0] = currentBlock;

	}


	function dropBlock() {
		
		if (currentBlock) {
			if (blocks[currentBlock.x][currentBlock.y+1] == undefined && currentBlock.y+1 < height) {
				blocks[currentBlock.x][currentBlock.y] = null;
				blocks[currentBlock.x][currentBlock.y+1] = currentBlock;
				currentBlock.y++;
				return true;
			} else {
				if (currentBlock.y == 0) {
					doGameOver();
				} else {
				console.log('Invalidating currentBlock');
				currentBlock == null;
				console.log('Spawning new block');
				spawnRandomBlock();

				return false;
				}
			}
		}

	}

	function fullDropBlock() {
		while(dropBlock() == true) {
			console.log('drop');
		}
		
	}
	function startGame() {
		blocks = new Array();
		for (var i = 0; i < width; i++) {
		blocks[i] = new Array();
		}

		gameInProgress = true;
		gameOver = false;
		currentBlock = null;
		dropBlockLoop = setInterval(dropBlock, 800);
		
		spawnRandomBlock();
		document.addEventListener('touchstart', handleTouchStart, false);        
		document.addEventListener('touchmove', handleTouchMove, false);
		startMusic();
	}
	function initGame() {
			loop = setInterval(gameTick, 16);

	}


	function doGameOver() {

		window.clearInterval(dropBlockLoop);
		gameInProgress = false;
		gameOver = true;
		setInterval(invertBlink, 400);
		stopMusic();
	}

	
document.addEventListener('keydown', handleKeyPress);

var xDown = null;                                                        
var yDown = null;                                                        


function handleKeyPress(e) {
	if (gameInProgress) { 
switch (e.keyCode) {
			// left
			case 37:
				moveLeft();
			break;
			case 32:
				fullDropBlock();
			break;
			// right
			case 39:
				moveRight();
			break;
			default:

			break;

		}
	}
	else {
		if (e.keyCode == 32) {
			startGame();
		}
	}
}
function handleTouchStart(evt) {                                         
    xDown = evt.touches[0].clientX;                                      
    yDown = evt.touches[0].clientY; 
    evt.preventDefault();                                     
};                                                
function handleTouchMove(evt) {
    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;
    var yDiff = yDown - yUp;

    if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {/*most significant*/
        if ( xDiff > 0 ) {
            /* left swipe */ 
            moveLeft();
        } else {
            /* right swipe */
            moveRight();
        }                       
    } else {
        if ( yDiff > 0 ) {
            /* up swipe */ 
            moveUp();
        } else { 
            /* down swipe */
            moveDown();
        }                                                                 
    }
    /* reset values */
    xDown = null;
    yDown = null;                                          
};
function moveDown() {
	
}
function moveUp() {
	
}
function moveLeft() {
if (currentBlock.x>0 && blocks[currentBlock.x-1][currentBlock.y] == null) {
blocks[currentBlock.x][currentBlock.y] = null;
blocks[currentBlock.x-1][currentBlock.y] = currentBlock;
currentBlock.x--;
}
}
function moveRight() {
if (currentBlock.x<width-1 && blocks[currentBlock.x+1][currentBlock.y] == null) {
blocks[currentBlock.x][currentBlock.y] = null;
blocks[currentBlock.x+1][currentBlock.y] = currentBlock;
currentBlock.x++;
}
}


var ac = new AudioContext();
	var leadGain = ac.createGain();
	leadGain.gain.value = 0.03;
	leadGain.connect(ac.destination);
var musicTimer;
function playFreq(freq,type,startTime, length) {
	var osc = ac.createOscillator();
	osc.type = type;
	osc.frequency.value = freq;
	osc.connect(leadGain);

	console.log('scheduling at ' + ac.currentTime + startTime);
	osc.start(ac.currentTime + startTime);
	osc.stop(ac.currentTime + startTime + length);


}
var bpm = 120;
var notes = [
				[49, 0, 0.15],
				[47, 0.15, 0.15],
				[49, 0.3, 0.15],
				[49, 0.6, 0.15],
				[51, 0.9, 0.15],
				[52, 1.2, 0.3],
				[51, 1.8, 0.3],
				[47, 2.25, 0.15],
				[42, 2.40, 0.15],
				[42, 2.7, 0.15],
				[42, 3, 0.15],
				[44, 3.3, 0.15],
				[45, 3.6, 0.3],
				[44, 4.2, 0.3],
				[49, 4.8, 0.15],
				[47, 4.95, 0.15],
				[49, 5.1, 0.15],
				[49, 5.4, 0.15],
				[51, 5.7, 0.15],
				[52, 6.0, 0.3],
				[51, 6.6, 0.3],
				[44, 7.05, 0.15],
				[54, 7.2, 0.15],
				[54, 7.5, 0.15],
				[54, 7.8, 0.15],
				[52, 8.1, 0.15],
				[51, 8.4, 0.3],
				[52, 9.0, 0.3],
				[-100, 9.3, 0.3]
				];
var notesDrums = [
				[13, 0, 0.15],
				[25,0.6, 0.15],
				[13,1.2, 0.15],
				[25,1.8, 0.15],
				[13,2.4, 0.15],
				[25,3, 0.15],
				[13,3.6, 0.15],
				[25,4.2, 0.15],
				[13,4.8, 0.15],
				[25,5.4, 0.15],
				[13,6, 0.15],
				[25,6.6, 0.15],
				[13,7.2, 0.15],
				[25,7.8, 0.15],
				[13,8.4, 0.15],
				[25,9, 0.15],
				];
var notesBass = [
				[25, 0, 1.8],
				[21, 1.8, 0.6],
				[18, 2.4, 1.8],
				[23, 4.2, 0.6],
				[25, 4.8, 1.8],
				[21, 6.6, 0.6],
				[23, 7.2, 2.4],

				];

function getKeyFreq(key) {
	var tot = 1.0594630943592953;
	return Math.pow(tot, key-49) * 440;
}
function scheduleKey(tone,wave, startTime,length) {
	playFreq(getKeyFreq(tone), wave, startTime, length);
}


initGame();

function playOneTime() {
	for (var i=0; i<notes.length; i++) {
		scheduleKey(notes[i][0],'square', notes[i][1], notes[i][2]);
	}
	for (var j=0; j<notesDrums.length; j++) {
		scheduleKey(notesDrums[j][0],'sawtooth', notesDrums[j][1], notesDrums[j][2]);
	}
	for (var k=0; k<notesBass.length; k++) {
		scheduleKey(notesBass[k][0],'sine', notesBass[k][1], notesBass[k][2]);
	}
}
function startMusic() {
	leadGain.gain.value = 0.03;
	var fullLength = notes[notes.length-1][1] + notes[notes.length-1][2];
	playOneTime();
	musicTimer = setInterval(playOneTime, fullLength*1000);
}
function stopMusic() {
	leadGain.gain.value = 0;
	window.clearInterval(musicTimer);
}
</script>
</body>
</html>